{"ast":null,"code":"import { flatten } from 'lodash';\nimport { put, select } from 'redux-saga/effects';\nimport { createSagas } from '@lib/redux';\nimport { messageService } from '@services/message.service';\nimport { message } from 'antd';\nimport { getConversations, getConversationsSuccess, getConversationsFail, setActiveConversation, setActiveConversationSuccess, loadMessages, fetchingMessage, loadMessagesSuccess, sendMessage, sendMessageFail, sendMessageSuccess, getConversationDetail, getConversationDetailSuccess, readMessages, loadMoreMessages, loadMoreMessagesSuccess, searchConversations, searchConversationsFail, searchConversationsSuccess } from './actions';\nconst conversationSagas = [{\n  on: getConversations,\n\n  *worker(data) {\n    try {\n      const resp = yield messageService.getConversations(data.payload);\n      yield put(getConversationsSuccess(resp.data));\n    } catch (e) {\n      // TODO - alert error\n      const error = yield Promise.resolve(e);\n      yield put(getConversationsFail(error));\n    }\n  }\n\n}, {\n  on: searchConversations,\n\n  *worker(data) {\n    try {\n      const resp = yield messageService.getConversations(data.payload);\n      yield put(searchConversationsSuccess(resp.data));\n    } catch (e) {\n      // TODO - alert error\n      const error = yield Promise.resolve(e);\n      yield put(searchConversationsFail(error));\n    }\n  }\n\n}, {\n  on: setActiveConversation,\n\n  *worker(data) {\n    try {\n      const {\n        source,\n        sourceId,\n        conversationId\n      } = data.payload;\n      const conversationMapping = yield select(state => state.conversation.mapping);\n\n      if (conversationId) {\n        if (conversationMapping[conversationId]) {\n          yield put(setActiveConversationSuccess(conversationMapping[conversationId]));\n          const readAllMessages = yield messageService.readAllInConversation(conversationId);\n\n          if (readAllMessages) {\n            yield put(readMessages(conversationId));\n          }\n\n          yield put(loadMessages({\n            conversationId,\n            limit: 25,\n            offset: 0\n          }));\n        }\n      } else {\n        const resp = yield messageService.createConversation({\n          source,\n          sourceId\n        });\n        const conversation = resp.data;\n\n        if (conversationMapping[conversation._id]) {\n          yield put(setActiveConversationSuccess(conversationMapping[conversation._id]));\n        } else {\n          yield put(setActiveConversationSuccess(conversation));\n        }\n\n        yield put(loadMessages({\n          conversationId: conversation._id,\n          limit: 25,\n          offset: 0\n        }));\n      }\n    } catch (e) {\n      message.error('Error occured, please try again later');\n    }\n  }\n\n}, {\n  on: getConversationDetail,\n\n  *worker(data) {\n    try {\n      const conversation = yield messageService.getConversationDetail(data.payload.id);\n      yield put(getConversationDetailSuccess(conversation.data));\n    } catch (e) {\n      yield put(getConversationsFail(e));\n    }\n  }\n\n}];\nconst messageSagas = [{\n  on: loadMessages,\n\n  *worker(data) {\n    try {\n      const messageMap = select(state => state.message.mapping);\n      const {\n        conversationId,\n        offset,\n        limit\n      } = data.payload;\n\n      if (messageMap[conversationId] && messageMap[conversationId].fetching) {\n        // do nothing if it is fetching\n        return;\n      }\n\n      yield put(fetchingMessage({\n        conversationId\n      }));\n      const resp = yield messageService.getMessages(conversationId, {\n        offset,\n        limit\n      });\n      yield put(loadMessagesSuccess({\n        conversationId,\n        items: resp.data.data,\n        total: resp.data.total\n      }));\n    } catch (e) {\n      message.error('Error occured, please try again later');\n    }\n  }\n\n}, {\n  on: loadMoreMessages,\n\n  *worker(data) {\n    try {\n      const messageMap = select(state => state.message.mapping);\n      const {\n        conversationId,\n        offset,\n        limit\n      } = data.payload;\n\n      if (messageMap[conversationId] && messageMap[conversationId].fetching) {\n        // do nothing if it is fetching\n        return;\n      }\n\n      yield put(fetchingMessage({\n        conversationId\n      }));\n      const resp = yield messageService.getMessages(conversationId, {\n        offset,\n        limit\n      });\n      yield put(loadMoreMessagesSuccess({\n        conversationId,\n        items: resp.data.data,\n        total: resp.data.total\n      }));\n    } catch (e) {\n      message.error('Error occured, please try again later'); // console.log('err', e);\n    }\n  }\n\n}, {\n  on: sendMessage,\n\n  *worker(req) {\n    try {\n      const {\n        conversationId,\n        data\n      } = req.payload;\n      const resp = yield messageService.sendMessage(conversationId, data);\n      yield put(sendMessageSuccess(resp.data));\n    } catch (e) {\n      yield put(sendMessageFail(e));\n    }\n  }\n\n}];\nexport default flatten([createSagas(conversationSagas), createSagas(messageSagas)]);","map":{"version":3,"sources":["c:/Users/Admin/Desktop/Work/foodiefans/foodiefans-main/user/src/redux/message/sagas.ts"],"names":["flatten","put","select","createSagas","messageService","message","getConversations","getConversationsSuccess","getConversationsFail","setActiveConversation","setActiveConversationSuccess","loadMessages","fetchingMessage","loadMessagesSuccess","sendMessage","sendMessageFail","sendMessageSuccess","getConversationDetail","getConversationDetailSuccess","readMessages","loadMoreMessages","loadMoreMessagesSuccess","searchConversations","searchConversationsFail","searchConversationsSuccess","conversationSagas","on","worker","data","resp","payload","e","error","Promise","resolve","source","sourceId","conversationId","conversationMapping","state","conversation","mapping","readAllMessages","readAllInConversation","limit","offset","createConversation","_id","id","messageSagas","messageMap","fetching","getMessages","items","total","req"],"mappings":"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","sourcesContent":["import { flatten } from 'lodash';\nimport { put, select } from 'redux-saga/effects';\nimport { createSagas } from '@lib/redux';\nimport { messageService } from '@services/message.service';\nimport { IReduxAction } from 'src/interfaces';\nimport { message } from 'antd';\nimport {\n  getConversations,\n  getConversationsSuccess,\n  getConversationsFail,\n  setActiveConversation,\n  setActiveConversationSuccess,\n  loadMessages,\n  fetchingMessage,\n  loadMessagesSuccess,\n  sendMessage,\n  sendMessageFail,\n  sendMessageSuccess,\n  getConversationDetail,\n  getConversationDetailSuccess,\n  readMessages,\n  loadMoreMessages,\n  loadMoreMessagesSuccess,\n  searchConversations,\n  searchConversationsFail,\n  searchConversationsSuccess\n} from './actions';\n\nconst conversationSagas = [\n  {\n    on: getConversations,\n    * worker(data: IReduxAction<Record<string, string>>) {\n      try {\n        const resp = yield messageService.getConversations(data.payload);\n        yield put(getConversationsSuccess(resp.data));\n      } catch (e) {\n        // TODO - alert error\n        const error = yield Promise.resolve(e);\n        yield put(getConversationsFail(error));\n      }\n    }\n  },\n  {\n    on: searchConversations,\n    * worker(data: IReduxAction<Record<string, string>>) {\n      try {\n        const resp = yield messageService.getConversations(data.payload);\n        yield put(searchConversationsSuccess(resp.data));\n      } catch (e) {\n        // TODO - alert error\n        const error = yield Promise.resolve(e);\n        yield put(searchConversationsFail(error));\n      }\n    }\n  },\n  {\n    on: setActiveConversation,\n    * worker(data: IReduxAction<Record<string, string>>) {\n      try {\n        const {\n          source, sourceId, conversationId\n        } = data.payload;\n        const conversationMapping = yield select((state) => state.conversation.mapping);\n        if (conversationId) {\n          if (conversationMapping[conversationId]) {\n            yield put(\n              setActiveConversationSuccess(conversationMapping[conversationId])\n            );\n\n            const readAllMessages = yield messageService.readAllInConversation(conversationId);\n            if (readAllMessages) {\n              yield put(readMessages(conversationId));\n            }\n            yield put(loadMessages({ conversationId, limit: 25, offset: 0 }));\n          }\n        } else {\n          const resp = yield messageService.createConversation({\n            source,\n            sourceId\n          });\n          const conversation = resp.data;\n          if (conversationMapping[conversation._id]) {\n            yield put(setActiveConversationSuccess(conversationMapping[conversation._id]));\n          } else {\n            yield put(setActiveConversationSuccess(conversation));\n          }\n          yield put(loadMessages({ conversationId: conversation._id, limit: 25, offset: 0 }));\n        }\n      } catch (e) {\n        message.error('Error occured, please try again later');\n      }\n    }\n  },\n  {\n    on: getConversationDetail,\n    * worker(data: IReduxAction<Record<string, string>>) {\n      try {\n        const conversation = yield messageService.getConversationDetail(data.payload.id);\n        yield put(getConversationDetailSuccess(conversation.data));\n      } catch (e) {\n        yield put(getConversationsFail(e));\n      }\n    }\n  }\n];\n\nconst messageSagas = [\n  {\n    on: loadMessages,\n    * worker(data: IReduxAction<Record<string, any>>) {\n      try {\n        const messageMap = select((state) => state.message.mapping);\n        const { conversationId, offset, limit } = data.payload;\n        if (messageMap[conversationId] && messageMap[conversationId].fetching) {\n          // do nothing if it is fetching\n          return;\n        }\n        yield put(fetchingMessage({ conversationId }));\n        const resp = yield messageService.getMessages(conversationId, { offset, limit });\n        yield put(\n          loadMessagesSuccess({\n            conversationId,\n            items: resp.data.data,\n            total: resp.data.total\n          })\n        );\n      } catch (e) {\n        message.error('Error occured, please try again later');\n      }\n    }\n  },\n  {\n    on: loadMoreMessages,\n    * worker(data: IReduxAction<Record<string, any>>) {\n      try {\n        const messageMap = select((state) => state.message.mapping);\n        const { conversationId, offset, limit } = data.payload;\n        if (messageMap[conversationId] && messageMap[conversationId].fetching) {\n          // do nothing if it is fetching\n          return;\n        }\n        yield put(fetchingMessage({ conversationId }));\n        const resp = yield messageService.getMessages(conversationId, { offset, limit });\n        yield put(\n          loadMoreMessagesSuccess({\n            conversationId,\n            items: resp.data.data,\n            total: resp.data.total\n          })\n        );\n      } catch (e) {\n        message.error('Error occured, please try again later');\n        // console.log('err', e);\n      }\n    }\n  },\n  {\n    on: sendMessage,\n    * worker(req: IReduxAction<any>) {\n      try {\n        const { conversationId, data } = req.payload;\n        const resp = yield messageService.sendMessage(conversationId, data);\n        yield put(sendMessageSuccess(resp.data));\n      } catch (e) {\n        yield put(sendMessageFail(e));\n      }\n    }\n  }\n];\n\nexport default flatten([\n  createSagas(conversationSagas),\n  createSagas(messageSagas)\n]);\n"]},"metadata":{},"sourceType":"module"}