{"ast":null,"code":"import React from \"react\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { Component, Children } from 'react';\nimport SocketIO from 'socket.io-client';\nimport { authService } from '@services/auth.service';\nimport { connect } from 'react-redux';\nimport { getGlobalConfig } from '@services/config';\nimport { warning, debug } from './utils';\nimport { SocketContext } from './SocketContext';\n\nclass Socket extends Component {\n  constructor(props) {\n    super(props);\n\n    _defineProperty(this, \"socket\", void 0);\n\n    this.connect();\n  }\n\n  shouldComponentUpdate(nextProps) {\n    const {\n      loggedIn\n    } = this.props;\n\n    if (nextProps.loggedIn !== loggedIn) {\n      this.connect();\n    }\n\n    return true;\n  }\n\n  componentWillUnmount() {\n    this.socket && this.socket.close();\n  }\n\n  login() {\n    if (!this.socket) {\n      return false;\n    }\n\n    const token = authService.getToken();\n    return this.socket.emit('auth/login', {\n      token\n    });\n  }\n\n  connect() {\n    const token = authService.getToken();\n\n    if (!false || !token) {\n      return;\n    }\n\n    const config = getGlobalConfig();\n    const {\n      uri = config.NEXT_PUBLIC_SOCKET_ENDPOINT\n    } = this.props;\n    const options = {\n      transports: ['websocket', 'polling', 'long-polling'],\n      query: token ? `token=${token}` : ''\n    };\n    this.socket = SocketIO(uri, this.mergeOptions(options));\n    this.socket.status = 'initialized';\n    this.socket.on('connect', () => {\n      this.socket.status = 'connected';\n\n      if (token) {\n        this.login();\n      }\n\n      debug('connected');\n    });\n    this.socket.on('disconnect', () => {\n      this.socket.status = 'disconnected';\n      debug('disconnect');\n    });\n    this.socket.on('error', err => {\n      this.socket.status = 'failed';\n      warning('error', err);\n    });\n    this.socket.on('reconnect', data => {\n      this.socket.status = 'connected';\n\n      if (token) {\n        this.login();\n      }\n\n      debug('reconnect', data);\n    });\n    this.socket.on('reconnect_attempt', () => {\n      debug('reconnect_attempt');\n    });\n    this.socket.on('reconnecting', () => {\n      this.socket.status = 'reconnecting';\n      debug('reconnecting');\n    });\n    this.socket.on('reconnect_failed', error => {\n      this.socket.status = 'failed';\n      warning('reconnect_failed', error);\n    });\n  }\n\n  mergeOptions(options = {}) {\n    const defaultOptions = {\n      reconnection: true,\n      reconnectionAttempts: Infinity,\n      reconnectionDelay: 1 * 1000,\n      reconnectionDelayMax: 10 * 1000,\n      autoConnect: true,\n      transports: ['websocket', 'polling', 'long-polling'],\n      rejectUnauthorized: true\n    };\n    return _objectSpread(_objectSpread({}, defaultOptions), options);\n  }\n\n  render() {\n    const {\n      children\n    } = this.props;\n    return __jsx(SocketContext.Provider, {\n      value: this.socket\n    }, Children.only(children));\n  }\n\n}\n\nconst mapStates = state => ({\n  loggedIn: state.auth.loggedIn\n});\n\nexport default connect(mapStates, null)(Socket);","map":{"version":3,"sources":["C:/Users/Admin/Desktop/Work/foodiefans/foodiefans-main/user/src/socket/Socket.tsx"],"names":["Component","Children","SocketIO","authService","connect","getGlobalConfig","warning","debug","SocketContext","Socket","constructor","props","shouldComponentUpdate","nextProps","loggedIn","componentWillUnmount","socket","close","login","token","getToken","emit","config","uri","NEXT_PUBLIC_SOCKET_ENDPOINT","options","transports","query","mergeOptions","status","on","err","data","error","defaultOptions","reconnection","reconnectionAttempts","Infinity","reconnectionDelay","reconnectionDelayMax","autoConnect","rejectUnauthorized","render","children","only","mapStates","state","auth"],"mappings":"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","sourcesContent":["import { Component, Children } from 'react';\nimport SocketIO from 'socket.io-client';\nimport { authService } from '@services/auth.service';\nimport { connect } from 'react-redux';\nimport { getGlobalConfig } from '@services/config';\nimport { warning, debug } from './utils';\nimport { SocketContext } from './SocketContext';\n\ninterface ISocketProps {\n  uri?: string;\n  children: any;\n  loggedIn: boolean;\n}\n\nclass Socket extends Component<ISocketProps> {\n  socket;\n\n  constructor(props) {\n    super(props);\n    this.connect();\n  }\n\n  shouldComponentUpdate(nextProps: any) {\n    const { loggedIn } = this.props;\n    if (nextProps.loggedIn !== loggedIn) {\n      this.connect();\n    }\n    return true;\n  }\n\n  componentWillUnmount() {\n    this.socket && this.socket.close();\n  }\n\n  login() {\n    if (!this.socket) {\n      return false;\n    }\n\n    const token = authService.getToken();\n    return this.socket.emit('auth/login', {\n      token\n    });\n  }\n\n  connect() {\n    const token = authService.getToken();\n    if (!process.browser || !token) {\n      return;\n    }\n    const config = getGlobalConfig();\n    const { uri = config.NEXT_PUBLIC_SOCKET_ENDPOINT } = this.props;\n    const options = {\n      transports: ['websocket', 'polling', 'long-polling'],\n      query: token ? `token=${token}` : ''\n    };\n    this.socket = SocketIO(uri, this.mergeOptions(options));\n\n    this.socket.status = 'initialized';\n\n    this.socket.on('connect', () => {\n      this.socket.status = 'connected';\n      if (token) {\n        this.login();\n      }\n      debug('connected');\n    });\n\n    this.socket.on('disconnect', () => {\n      this.socket.status = 'disconnected';\n      debug('disconnect');\n    });\n\n    this.socket.on('error', (err) => {\n      this.socket.status = 'failed';\n      warning('error', err);\n    });\n\n    this.socket.on('reconnect', (data) => {\n      this.socket.status = 'connected';\n      if (token) {\n        this.login();\n      }\n      debug('reconnect', data);\n    });\n\n    this.socket.on('reconnect_attempt', () => {\n      debug('reconnect_attempt');\n    });\n\n    this.socket.on('reconnecting', () => {\n      this.socket.status = 'reconnecting';\n      debug('reconnecting');\n    });\n\n    this.socket.on('reconnect_failed', (error) => {\n      this.socket.status = 'failed';\n      warning('reconnect_failed', error);\n    });\n  }\n\n  mergeOptions(options = {}) {\n    const defaultOptions = {\n      reconnection: true,\n      reconnectionAttempts: Infinity,\n      reconnectionDelay: 1 * 1000,\n      reconnectionDelayMax: 10 * 1000,\n      autoConnect: true,\n      transports: ['websocket', 'polling', 'long-polling'],\n      rejectUnauthorized: true\n    };\n    return { ...defaultOptions, ...options };\n  }\n\n  render() {\n    const { children } = this.props;\n    return (\n      <SocketContext.Provider value={this.socket}>\n        {Children.only(children)}\n      </SocketContext.Provider>\n    );\n  }\n}\n\nconst mapStates = (state: any) => ({\n  loggedIn: state.auth.loggedIn\n});\n\nexport default connect(mapStates, null)(Socket);\n"]},"metadata":{},"sourceType":"module"}